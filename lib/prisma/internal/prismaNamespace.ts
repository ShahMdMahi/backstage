/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client";
import type * as Prisma from "../models";
import { type PrismaClient } from "./class";

export type * from "../models";

export type DMMF = typeof runtime.DMMF;

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>;

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError =
  runtime.PrismaClientKnownRequestError;
export type PrismaClientKnownRequestError =
  runtime.PrismaClientKnownRequestError;

export const PrismaClientUnknownRequestError =
  runtime.PrismaClientUnknownRequestError;
export type PrismaClientUnknownRequestError =
  runtime.PrismaClientUnknownRequestError;

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;

export const PrismaClientInitializationError =
  runtime.PrismaClientInitializationError;
export type PrismaClientInitializationError =
  runtime.PrismaClientInitializationError;

export const PrismaClientValidationError = runtime.PrismaClientValidationError;
export type PrismaClientValidationError = runtime.PrismaClientValidationError;

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag;
export const empty = runtime.empty;
export const join = runtime.join;
export const raw = runtime.raw;
export const Sql = runtime.Sql;
export type Sql = runtime.Sql;

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal;
export type Decimal = runtime.Decimal;

export type DecimalJsLike = runtime.DecimalJsLike;

/**
 * Extensions
 */
export type Extension = runtime.Types.Extensions.UserArgs;
export const getExtensionContext = runtime.Extensions.getExtensionContext;
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<
  T,
  F
>;
export type Payload<
  T,
  F extends runtime.Operation = never,
> = runtime.Types.Public.Payload<T, F>;
export type Result<
  T,
  A,
  F extends runtime.Operation,
> = runtime.Types.Public.Result<T, A, F>;
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>;

export type PrismaVersion = {
  client: string;
  engine: string;
};

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3",
};

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes;
export type JsonObject = runtime.JsonObject;
export type JsonArray = runtime.JsonArray;
export type JsonValue = runtime.JsonValue;
export type InputJsonObject = runtime.InputJsonObject;
export type InputJsonArray = runtime.InputJsonArray;
export type InputJsonValue = runtime.InputJsonValue;

export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as new (
    secret: never
  ) => typeof runtime.DbNull,
  JsonNull: runtime.NullTypes.JsonNull as new (
    secret: never
  ) => typeof runtime.JsonNull,
  AnyNull: runtime.NullTypes.AnyNull as new (
    secret: never
  ) => typeof runtime.AnyNull,
};
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull;

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull;

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull;

type SelectAndInclude = {
  select: any;
  include: any;
};

type SelectAndOmit = {
  select: any;
  omit: any;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & (T extends SelectAndInclude
  ? "Please either choose `select` or `include`."
  : T extends SelectAndOmit
    ? "Please either choose `select` or `omit`."
    : {});

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & K;

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> = T extends object
  ? U extends object
    ? (Without<T, U> & U) | (Without<U, T> & T)
    : U
  : T;

/**
 * Is T a Record?
 */
type IsObject<T extends any> =
  T extends Array<any>
    ? False
    : T extends Date
      ? False
      : T extends Uint8Array
        ? False
        : T extends BigInt
          ? False
          : T extends object
            ? True
            : False;

/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
  }[K];

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

type _Either<O extends object, K extends Key, strict extends Boolean> = {
  1: EitherStrict<O, K>;
  0: EitherLoose<O, K>;
}[strict];

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1,
> = O extends unknown ? _Either<O, K, strict> : never;

export type Union = any;

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
} & {};

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never;

export type Overwrite<O extends object, O1 extends object> = {
  [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<
  Overwrite<
    U,
    {
      [K in keyof U]-?: At<U, K>;
    }
  >
>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown
  ? AtStrict<O, K>
  : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
  1: AtStrict<O, K>;
  0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function
  ? A
  : {
      [K in keyof A]: A[K];
    } & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
    ?
        | (K extends keyof O ? { [P in K]: O[P] } & O : O)
        | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
    : never
>;

type _Strict<U, _U = U> = U extends unknown
  ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
  : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False;

export type True = 1;

export type False = 0;

export type Not<B extends Boolean> = {
  0: 1;
  1: 0;
}[B];

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
    ? 1
    : 0;

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>;

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0;
    1: 1;
  };
  1: {
    0: 1;
    1: 1;
  };
}[B1][B2];

export type Keys<U extends Union> = U extends unknown ? keyof U : never;

export type GetScalarType<T, O> = O extends object
  ? {
      [P in keyof T]: P extends keyof O ? O[P] : never;
    }
  : never;

type FieldPaths<T, U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">> =
  IsObject<T> extends True ? U : T;

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<"OR", K>, Extends<"AND", K>>,
    Extends<"NOT", K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<
          UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
        >
      : never
    : {} extends FieldPaths<T[K]>
      ? never
      : K;
}[keyof T];

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<
  T,
  K extends Enumerable<keyof T> | keyof T,
> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
  ? never
  : T;

export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

type FieldRefInputType<Model, FieldType> = Model extends never
  ? never
  : FieldRef<Model, FieldType>;

export const ModelName = {
  User: "User",
  Session: "Session",
  SystemAccess: "SystemAccess",
  Reporting: "Reporting",
  WorkspaceAccount: "WorkspaceAccount",
  Release: "Release",
  Track: "Track",
  Video: "Video",
  Ringtone: "Ringtone",
  Artist: "Artist",
  Performer: "Performer",
  ProducerAndEngineer: "ProducerAndEngineer",
  ArtistPerformerProducerAndEngineer: "ArtistPerformerProducerAndEngineer",
  Writer: "Writer",
  Publisher: "Publisher",
  Label: "Label",
  Transaction: "Transaction",
  Withdrawal: "Withdrawal",
  Report: "Report",
  SharedWorkspaceAccountAccess: "SharedWorkspaceAccountAccess",
  RightsManagement: "RightsManagement",
  AuditLog: "AuditLog",
} as const;

export type ModelName = (typeof ModelName)[keyof typeof ModelName];

export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils
  .Fn<
  { extArgs: runtime.Types.Extensions.InternalArgs },
  runtime.Types.Utils.Record<string, any>
> {
  returns: TypeMap<this["params"]["extArgs"], GlobalOmitOptions>;
}

export type TypeMap<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions;
  };
  meta: {
    modelProps:
      | "user"
      | "session"
      | "systemAccess"
      | "reporting"
      | "workspaceAccount"
      | "release"
      | "track"
      | "video"
      | "ringtone"
      | "artist"
      | "performer"
      | "producerAndEngineer"
      | "artistPerformerProducerAndEngineer"
      | "writer"
      | "publisher"
      | "label"
      | "transaction"
      | "withdrawal"
      | "report"
      | "sharedWorkspaceAccountAccess"
      | "rightsManagement"
      | "auditLog";
    txIsolationLevel: TransactionIsolationLevel;
  };
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>;
      fields: Prisma.UserFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>;
        };
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[];
        };
        count: {
          args: Prisma.UserCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType>
            | number;
        };
      };
    };
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>;
      fields: Prisma.SessionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
        };
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
        };
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
        };
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>;
        };
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[];
        };
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType>
            | number;
        };
      };
    };
    SystemAccess: {
      payload: Prisma.$SystemAccessPayload<ExtArgs>;
      fields: Prisma.SystemAccessFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SystemAccessFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SystemAccessFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload>;
        };
        findFirst: {
          args: Prisma.SystemAccessFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SystemAccessFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload>;
        };
        findMany: {
          args: Prisma.SystemAccessFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload>[];
        };
        create: {
          args: Prisma.SystemAccessCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload>;
        };
        createMany: {
          args: Prisma.SystemAccessCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SystemAccessCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload>[];
        };
        delete: {
          args: Prisma.SystemAccessDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload>;
        };
        update: {
          args: Prisma.SystemAccessUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload>;
        };
        deleteMany: {
          args: Prisma.SystemAccessDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SystemAccessUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SystemAccessUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload>[];
        };
        upsert: {
          args: Prisma.SystemAccessUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemAccessPayload>;
        };
        aggregate: {
          args: Prisma.SystemAccessAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSystemAccess>;
        };
        groupBy: {
          args: Prisma.SystemAccessGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SystemAccessGroupByOutputType>[];
        };
        count: {
          args: Prisma.SystemAccessCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SystemAccessCountAggregateOutputType>
            | number;
        };
      };
    };
    Reporting: {
      payload: Prisma.$ReportingPayload<ExtArgs>;
      fields: Prisma.ReportingFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ReportingFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ReportingFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        findFirst: {
          args: Prisma.ReportingFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ReportingFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        findMany: {
          args: Prisma.ReportingFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>[];
        };
        create: {
          args: Prisma.ReportingCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        createMany: {
          args: Prisma.ReportingCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ReportingCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>[];
        };
        delete: {
          args: Prisma.ReportingDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        update: {
          args: Prisma.ReportingUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        deleteMany: {
          args: Prisma.ReportingDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ReportingUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ReportingUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>[];
        };
        upsert: {
          args: Prisma.ReportingUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportingPayload>;
        };
        aggregate: {
          args: Prisma.ReportingAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateReporting>;
        };
        groupBy: {
          args: Prisma.ReportingGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ReportingGroupByOutputType>[];
        };
        count: {
          args: Prisma.ReportingCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ReportingCountAggregateOutputType>
            | number;
        };
      };
    };
    WorkspaceAccount: {
      payload: Prisma.$WorkspaceAccountPayload<ExtArgs>;
      fields: Prisma.WorkspaceAccountFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.WorkspaceAccountFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.WorkspaceAccountFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload>;
        };
        findFirst: {
          args: Prisma.WorkspaceAccountFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.WorkspaceAccountFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload>;
        };
        findMany: {
          args: Prisma.WorkspaceAccountFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload>[];
        };
        create: {
          args: Prisma.WorkspaceAccountCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload>;
        };
        createMany: {
          args: Prisma.WorkspaceAccountCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.WorkspaceAccountCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload>[];
        };
        delete: {
          args: Prisma.WorkspaceAccountDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload>;
        };
        update: {
          args: Prisma.WorkspaceAccountUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload>;
        };
        deleteMany: {
          args: Prisma.WorkspaceAccountDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.WorkspaceAccountUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.WorkspaceAccountUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload>[];
        };
        upsert: {
          args: Prisma.WorkspaceAccountUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceAccountPayload>;
        };
        aggregate: {
          args: Prisma.WorkspaceAccountAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkspaceAccount>;
        };
        groupBy: {
          args: Prisma.WorkspaceAccountGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.WorkspaceAccountGroupByOutputType>[];
        };
        count: {
          args: Prisma.WorkspaceAccountCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.WorkspaceAccountCountAggregateOutputType>
            | number;
        };
      };
    };
    Release: {
      payload: Prisma.$ReleasePayload<ExtArgs>;
      fields: Prisma.ReleaseFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ReleaseFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ReleaseFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload>;
        };
        findFirst: {
          args: Prisma.ReleaseFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ReleaseFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload>;
        };
        findMany: {
          args: Prisma.ReleaseFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload>[];
        };
        create: {
          args: Prisma.ReleaseCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload>;
        };
        createMany: {
          args: Prisma.ReleaseCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ReleaseCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload>[];
        };
        delete: {
          args: Prisma.ReleaseDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload>;
        };
        update: {
          args: Prisma.ReleaseUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload>;
        };
        deleteMany: {
          args: Prisma.ReleaseDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ReleaseUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ReleaseUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload>[];
        };
        upsert: {
          args: Prisma.ReleaseUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleasePayload>;
        };
        aggregate: {
          args: Prisma.ReleaseAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRelease>;
        };
        groupBy: {
          args: Prisma.ReleaseGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ReleaseGroupByOutputType>[];
        };
        count: {
          args: Prisma.ReleaseCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ReleaseCountAggregateOutputType>
            | number;
        };
      };
    };
    Track: {
      payload: Prisma.$TrackPayload<ExtArgs>;
      fields: Prisma.TrackFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TrackFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TrackFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>;
        };
        findFirst: {
          args: Prisma.TrackFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TrackFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>;
        };
        findMany: {
          args: Prisma.TrackFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>[];
        };
        create: {
          args: Prisma.TrackCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>;
        };
        createMany: {
          args: Prisma.TrackCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TrackCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>[];
        };
        delete: {
          args: Prisma.TrackDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>;
        };
        update: {
          args: Prisma.TrackUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>;
        };
        deleteMany: {
          args: Prisma.TrackDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TrackUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TrackUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>[];
        };
        upsert: {
          args: Prisma.TrackUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>;
        };
        aggregate: {
          args: Prisma.TrackAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrack>;
        };
        groupBy: {
          args: Prisma.TrackGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TrackGroupByOutputType>[];
        };
        count: {
          args: Prisma.TrackCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TrackCountAggregateOutputType>
            | number;
        };
      };
    };
    Video: {
      payload: Prisma.$VideoPayload<ExtArgs>;
      fields: Prisma.VideoFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.VideoFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload>;
        };
        findFirst: {
          args: Prisma.VideoFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload>;
        };
        findMany: {
          args: Prisma.VideoFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload>[];
        };
        create: {
          args: Prisma.VideoCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload>;
        };
        createMany: {
          args: Prisma.VideoCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.VideoCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload>[];
        };
        delete: {
          args: Prisma.VideoDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload>;
        };
        update: {
          args: Prisma.VideoUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload>;
        };
        deleteMany: {
          args: Prisma.VideoDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.VideoUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.VideoUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload>[];
        };
        upsert: {
          args: Prisma.VideoUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VideoPayload>;
        };
        aggregate: {
          args: Prisma.VideoAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateVideo>;
        };
        groupBy: {
          args: Prisma.VideoGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.VideoGroupByOutputType>[];
        };
        count: {
          args: Prisma.VideoCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.VideoCountAggregateOutputType>
            | number;
        };
      };
    };
    Ringtone: {
      payload: Prisma.$RingtonePayload<ExtArgs>;
      fields: Prisma.RingtoneFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RingtoneFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RingtoneFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload>;
        };
        findFirst: {
          args: Prisma.RingtoneFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RingtoneFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload>;
        };
        findMany: {
          args: Prisma.RingtoneFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload>[];
        };
        create: {
          args: Prisma.RingtoneCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload>;
        };
        createMany: {
          args: Prisma.RingtoneCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RingtoneCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload>[];
        };
        delete: {
          args: Prisma.RingtoneDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload>;
        };
        update: {
          args: Prisma.RingtoneUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload>;
        };
        deleteMany: {
          args: Prisma.RingtoneDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RingtoneUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RingtoneUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload>[];
        };
        upsert: {
          args: Prisma.RingtoneUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RingtonePayload>;
        };
        aggregate: {
          args: Prisma.RingtoneAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRingtone>;
        };
        groupBy: {
          args: Prisma.RingtoneGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RingtoneGroupByOutputType>[];
        };
        count: {
          args: Prisma.RingtoneCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RingtoneCountAggregateOutputType>
            | number;
        };
      };
    };
    Artist: {
      payload: Prisma.$ArtistPayload<ExtArgs>;
      fields: Prisma.ArtistFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ArtistFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ArtistFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload>;
        };
        findFirst: {
          args: Prisma.ArtistFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ArtistFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload>;
        };
        findMany: {
          args: Prisma.ArtistFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload>[];
        };
        create: {
          args: Prisma.ArtistCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload>;
        };
        createMany: {
          args: Prisma.ArtistCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ArtistCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload>[];
        };
        delete: {
          args: Prisma.ArtistDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload>;
        };
        update: {
          args: Prisma.ArtistUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload>;
        };
        deleteMany: {
          args: Prisma.ArtistDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ArtistUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ArtistUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload>[];
        };
        upsert: {
          args: Prisma.ArtistUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPayload>;
        };
        aggregate: {
          args: Prisma.ArtistAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateArtist>;
        };
        groupBy: {
          args: Prisma.ArtistGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ArtistGroupByOutputType>[];
        };
        count: {
          args: Prisma.ArtistCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ArtistCountAggregateOutputType>
            | number;
        };
      };
    };
    Performer: {
      payload: Prisma.$PerformerPayload<ExtArgs>;
      fields: Prisma.PerformerFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PerformerFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PerformerFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload>;
        };
        findFirst: {
          args: Prisma.PerformerFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PerformerFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload>;
        };
        findMany: {
          args: Prisma.PerformerFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload>[];
        };
        create: {
          args: Prisma.PerformerCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload>;
        };
        createMany: {
          args: Prisma.PerformerCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PerformerCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload>[];
        };
        delete: {
          args: Prisma.PerformerDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload>;
        };
        update: {
          args: Prisma.PerformerUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload>;
        };
        deleteMany: {
          args: Prisma.PerformerDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PerformerUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PerformerUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload>[];
        };
        upsert: {
          args: Prisma.PerformerUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformerPayload>;
        };
        aggregate: {
          args: Prisma.PerformerAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePerformer>;
        };
        groupBy: {
          args: Prisma.PerformerGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PerformerGroupByOutputType>[];
        };
        count: {
          args: Prisma.PerformerCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PerformerCountAggregateOutputType>
            | number;
        };
      };
    };
    ProducerAndEngineer: {
      payload: Prisma.$ProducerAndEngineerPayload<ExtArgs>;
      fields: Prisma.ProducerAndEngineerFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ProducerAndEngineerFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ProducerAndEngineerFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload>;
        };
        findFirst: {
          args: Prisma.ProducerAndEngineerFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ProducerAndEngineerFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload>;
        };
        findMany: {
          args: Prisma.ProducerAndEngineerFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload>[];
        };
        create: {
          args: Prisma.ProducerAndEngineerCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload>;
        };
        createMany: {
          args: Prisma.ProducerAndEngineerCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ProducerAndEngineerCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload>[];
        };
        delete: {
          args: Prisma.ProducerAndEngineerDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload>;
        };
        update: {
          args: Prisma.ProducerAndEngineerUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload>;
        };
        deleteMany: {
          args: Prisma.ProducerAndEngineerDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ProducerAndEngineerUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ProducerAndEngineerUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload>[];
        };
        upsert: {
          args: Prisma.ProducerAndEngineerUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProducerAndEngineerPayload>;
        };
        aggregate: {
          args: Prisma.ProducerAndEngineerAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateProducerAndEngineer>;
        };
        groupBy: {
          args: Prisma.ProducerAndEngineerGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ProducerAndEngineerGroupByOutputType>[];
        };
        count: {
          args: Prisma.ProducerAndEngineerCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ProducerAndEngineerCountAggregateOutputType>
            | number;
        };
      };
    };
    ArtistPerformerProducerAndEngineer: {
      payload: Prisma.$ArtistPerformerProducerAndEngineerPayload<ExtArgs>;
      fields: Prisma.ArtistPerformerProducerAndEngineerFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ArtistPerformerProducerAndEngineerFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ArtistPerformerProducerAndEngineerFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload>;
        };
        findFirst: {
          args: Prisma.ArtistPerformerProducerAndEngineerFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ArtistPerformerProducerAndEngineerFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload>;
        };
        findMany: {
          args: Prisma.ArtistPerformerProducerAndEngineerFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload>[];
        };
        create: {
          args: Prisma.ArtistPerformerProducerAndEngineerCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload>;
        };
        createMany: {
          args: Prisma.ArtistPerformerProducerAndEngineerCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ArtistPerformerProducerAndEngineerCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload>[];
        };
        delete: {
          args: Prisma.ArtistPerformerProducerAndEngineerDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload>;
        };
        update: {
          args: Prisma.ArtistPerformerProducerAndEngineerUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload>;
        };
        deleteMany: {
          args: Prisma.ArtistPerformerProducerAndEngineerDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ArtistPerformerProducerAndEngineerUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ArtistPerformerProducerAndEngineerUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload>[];
        };
        upsert: {
          args: Prisma.ArtistPerformerProducerAndEngineerUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtistPerformerProducerAndEngineerPayload>;
        };
        aggregate: {
          args: Prisma.ArtistPerformerProducerAndEngineerAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateArtistPerformerProducerAndEngineer>;
        };
        groupBy: {
          args: Prisma.ArtistPerformerProducerAndEngineerGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ArtistPerformerProducerAndEngineerGroupByOutputType>[];
        };
        count: {
          args: Prisma.ArtistPerformerProducerAndEngineerCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ArtistPerformerProducerAndEngineerCountAggregateOutputType>
            | number;
        };
      };
    };
    Writer: {
      payload: Prisma.$WriterPayload<ExtArgs>;
      fields: Prisma.WriterFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.WriterFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.WriterFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload>;
        };
        findFirst: {
          args: Prisma.WriterFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.WriterFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload>;
        };
        findMany: {
          args: Prisma.WriterFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload>[];
        };
        create: {
          args: Prisma.WriterCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload>;
        };
        createMany: {
          args: Prisma.WriterCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.WriterCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload>[];
        };
        delete: {
          args: Prisma.WriterDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload>;
        };
        update: {
          args: Prisma.WriterUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload>;
        };
        deleteMany: {
          args: Prisma.WriterDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.WriterUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.WriterUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload>[];
        };
        upsert: {
          args: Prisma.WriterUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WriterPayload>;
        };
        aggregate: {
          args: Prisma.WriterAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateWriter>;
        };
        groupBy: {
          args: Prisma.WriterGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.WriterGroupByOutputType>[];
        };
        count: {
          args: Prisma.WriterCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.WriterCountAggregateOutputType>
            | number;
        };
      };
    };
    Publisher: {
      payload: Prisma.$PublisherPayload<ExtArgs>;
      fields: Prisma.PublisherFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PublisherFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PublisherFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload>;
        };
        findFirst: {
          args: Prisma.PublisherFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PublisherFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload>;
        };
        findMany: {
          args: Prisma.PublisherFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload>[];
        };
        create: {
          args: Prisma.PublisherCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload>;
        };
        createMany: {
          args: Prisma.PublisherCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PublisherCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload>[];
        };
        delete: {
          args: Prisma.PublisherDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload>;
        };
        update: {
          args: Prisma.PublisherUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload>;
        };
        deleteMany: {
          args: Prisma.PublisherDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PublisherUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PublisherUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload>[];
        };
        upsert: {
          args: Prisma.PublisherUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublisherPayload>;
        };
        aggregate: {
          args: Prisma.PublisherAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePublisher>;
        };
        groupBy: {
          args: Prisma.PublisherGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PublisherGroupByOutputType>[];
        };
        count: {
          args: Prisma.PublisherCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PublisherCountAggregateOutputType>
            | number;
        };
      };
    };
    Label: {
      payload: Prisma.$LabelPayload<ExtArgs>;
      fields: Prisma.LabelFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.LabelFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.LabelFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload>;
        };
        findFirst: {
          args: Prisma.LabelFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.LabelFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload>;
        };
        findMany: {
          args: Prisma.LabelFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload>[];
        };
        create: {
          args: Prisma.LabelCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload>;
        };
        createMany: {
          args: Prisma.LabelCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.LabelCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload>[];
        };
        delete: {
          args: Prisma.LabelDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload>;
        };
        update: {
          args: Prisma.LabelUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload>;
        };
        deleteMany: {
          args: Prisma.LabelDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.LabelUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.LabelUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload>[];
        };
        upsert: {
          args: Prisma.LabelUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabelPayload>;
        };
        aggregate: {
          args: Prisma.LabelAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateLabel>;
        };
        groupBy: {
          args: Prisma.LabelGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.LabelGroupByOutputType>[];
        };
        count: {
          args: Prisma.LabelCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.LabelCountAggregateOutputType>
            | number;
        };
      };
    };
    Transaction: {
      payload: Prisma.$TransactionPayload<ExtArgs>;
      fields: Prisma.TransactionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TransactionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        findFirst: {
          args: Prisma.TransactionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        findMany: {
          args: Prisma.TransactionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[];
        };
        create: {
          args: Prisma.TransactionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        createMany: {
          args: Prisma.TransactionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[];
        };
        delete: {
          args: Prisma.TransactionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        update: {
          args: Prisma.TransactionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        deleteMany: {
          args: Prisma.TransactionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TransactionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[];
        };
        upsert: {
          args: Prisma.TransactionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>;
        };
        aggregate: {
          args: Prisma.TransactionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>;
        };
        groupBy: {
          args: Prisma.TransactionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[];
        };
        count: {
          args: Prisma.TransactionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType>
            | number;
        };
      };
    };
    Withdrawal: {
      payload: Prisma.$WithdrawalPayload<ExtArgs>;
      fields: Prisma.WithdrawalFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.WithdrawalFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.WithdrawalFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload>;
        };
        findFirst: {
          args: Prisma.WithdrawalFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.WithdrawalFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload>;
        };
        findMany: {
          args: Prisma.WithdrawalFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload>[];
        };
        create: {
          args: Prisma.WithdrawalCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload>;
        };
        createMany: {
          args: Prisma.WithdrawalCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.WithdrawalCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload>[];
        };
        delete: {
          args: Prisma.WithdrawalDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload>;
        };
        update: {
          args: Prisma.WithdrawalUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload>;
        };
        deleteMany: {
          args: Prisma.WithdrawalDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.WithdrawalUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.WithdrawalUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload>[];
        };
        upsert: {
          args: Prisma.WithdrawalUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WithdrawalPayload>;
        };
        aggregate: {
          args: Prisma.WithdrawalAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateWithdrawal>;
        };
        groupBy: {
          args: Prisma.WithdrawalGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.WithdrawalGroupByOutputType>[];
        };
        count: {
          args: Prisma.WithdrawalCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.WithdrawalCountAggregateOutputType>
            | number;
        };
      };
    };
    Report: {
      payload: Prisma.$ReportPayload<ExtArgs>;
      fields: Prisma.ReportFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ReportFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        findFirst: {
          args: Prisma.ReportFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        findMany: {
          args: Prisma.ReportFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[];
        };
        create: {
          args: Prisma.ReportCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        createMany: {
          args: Prisma.ReportCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[];
        };
        delete: {
          args: Prisma.ReportDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        update: {
          args: Prisma.ReportUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        deleteMany: {
          args: Prisma.ReportDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ReportUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[];
        };
        upsert: {
          args: Prisma.ReportUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
        };
        aggregate: {
          args: Prisma.ReportAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateReport>;
        };
        groupBy: {
          args: Prisma.ReportGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ReportGroupByOutputType>[];
        };
        count: {
          args: Prisma.ReportCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ReportCountAggregateOutputType>
            | number;
        };
      };
    };
    SharedWorkspaceAccountAccess: {
      payload: Prisma.$SharedWorkspaceAccountAccessPayload<ExtArgs>;
      fields: Prisma.SharedWorkspaceAccountAccessFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SharedWorkspaceAccountAccessFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SharedWorkspaceAccountAccessFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload>;
        };
        findFirst: {
          args: Prisma.SharedWorkspaceAccountAccessFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SharedWorkspaceAccountAccessFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload>;
        };
        findMany: {
          args: Prisma.SharedWorkspaceAccountAccessFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload>[];
        };
        create: {
          args: Prisma.SharedWorkspaceAccountAccessCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload>;
        };
        createMany: {
          args: Prisma.SharedWorkspaceAccountAccessCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SharedWorkspaceAccountAccessCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload>[];
        };
        delete: {
          args: Prisma.SharedWorkspaceAccountAccessDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload>;
        };
        update: {
          args: Prisma.SharedWorkspaceAccountAccessUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload>;
        };
        deleteMany: {
          args: Prisma.SharedWorkspaceAccountAccessDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SharedWorkspaceAccountAccessUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SharedWorkspaceAccountAccessUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload>[];
        };
        upsert: {
          args: Prisma.SharedWorkspaceAccountAccessUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharedWorkspaceAccountAccessPayload>;
        };
        aggregate: {
          args: Prisma.SharedWorkspaceAccountAccessAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSharedWorkspaceAccountAccess>;
        };
        groupBy: {
          args: Prisma.SharedWorkspaceAccountAccessGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SharedWorkspaceAccountAccessGroupByOutputType>[];
        };
        count: {
          args: Prisma.SharedWorkspaceAccountAccessCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SharedWorkspaceAccountAccessCountAggregateOutputType>
            | number;
        };
      };
    };
    RightsManagement: {
      payload: Prisma.$RightsManagementPayload<ExtArgs>;
      fields: Prisma.RightsManagementFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RightsManagementFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RightsManagementFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload>;
        };
        findFirst: {
          args: Prisma.RightsManagementFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RightsManagementFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload>;
        };
        findMany: {
          args: Prisma.RightsManagementFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload>[];
        };
        create: {
          args: Prisma.RightsManagementCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload>;
        };
        createMany: {
          args: Prisma.RightsManagementCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RightsManagementCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload>[];
        };
        delete: {
          args: Prisma.RightsManagementDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload>;
        };
        update: {
          args: Prisma.RightsManagementUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload>;
        };
        deleteMany: {
          args: Prisma.RightsManagementDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RightsManagementUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RightsManagementUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload>[];
        };
        upsert: {
          args: Prisma.RightsManagementUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RightsManagementPayload>;
        };
        aggregate: {
          args: Prisma.RightsManagementAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRightsManagement>;
        };
        groupBy: {
          args: Prisma.RightsManagementGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RightsManagementGroupByOutputType>[];
        };
        count: {
          args: Prisma.RightsManagementCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RightsManagementCountAggregateOutputType>
            | number;
        };
      };
    };
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>;
      fields: Prisma.AuditLogFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
        };
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
        };
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
        };
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>;
        };
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[];
        };
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType>
            | number;
        };
      };
    };
  };
} & {
  other: {
    payload: any;
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
    };
  };
};

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: "ReadUncommitted",
  ReadCommitted: "ReadCommitted",
  RepeatableRead: "RepeatableRead",
  Serializable: "Serializable",
} as const);

export type TransactionIsolationLevel =
  (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

export const UserScalarFieldEnum = {
  id: "id",
  ownWorkspaceAccountId: "ownWorkspaceAccountId",
  name: "name",
  email: "email",
  password: "password",
  phone: "phone",
  avatar: "avatar",
  metadata: "metadata",
  role: "role",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  verifiedAt: "verifiedAt",
  approvedAt: "approvedAt",
  suspendedAt: "suspendedAt",
} as const;

export type UserScalarFieldEnum =
  (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

export const SessionScalarFieldEnum = {
  id: "id",
  userId: "userId",
  token: "token",
  userAgent: "userAgent",
  ipAddress: "ipAddress",
  deviceFingerprint: "deviceFingerprint",
  metadata: "metadata",
  deviceType: "deviceType",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  expiresAt: "expiresAt",
  revokedAt: "revokedAt",
  accessedAt: "accessedAt",
} as const;

export type SessionScalarFieldEnum =
  (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

export const SystemAccessScalarFieldEnum = {
  id: "id",
  userId: "userId",
  assignerId: "assignerId",
  usersAccessLevel: "usersAccessLevel",
  workspaceAccountsAccessLevel: "workspaceAccountsAccessLevel",
  reportingAccessLevel: "reportingAccessLevel",
  releasesAccessLevel: "releasesAccessLevel",
  tracksAccessLevel: "tracksAccessLevel",
  videosAccessLevel: "videosAccessLevel",
  ringtonesAccessLevel: "ringtonesAccessLevel",
  artistsAccessLevel: "artistsAccessLevel",
  performersAccessLevel: "performersAccessLevel",
  producersAndEngineersAccessLevel: "producersAndEngineersAccessLevel",
  writersAccessLevel: "writersAccessLevel",
  publishersAccessLevel: "publishersAccessLevel",
  labelsAccessLevel: "labelsAccessLevel",
  transactionsAccessLevel: "transactionsAccessLevel",
  withdrawsAccessLevel: "withdrawsAccessLevel",
  consumptionAccessLevel: "consumptionAccessLevel",
  engagementAccessLevel: "engagementAccessLevel",
  revenueAccessLevel: "revenueAccessLevel",
  geoAccessLevel: "geoAccessLevel",
  rightsManagementAccessLevel: "rightsManagementAccessLevel",
  metadata: "metadata",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  suspendedAt: "suspendedAt",
  expiresAt: "expiresAt",
} as const;

export type SystemAccessScalarFieldEnum =
  (typeof SystemAccessScalarFieldEnum)[keyof typeof SystemAccessScalarFieldEnum];

export const ReportingScalarFieldEnum = {
  id: "id",
  uploaderId: "uploaderId",
  processorId: "processorId",
  name: "name",
  raw: "raw",
  hash: "hash",
  reportingMonth: "reportingMonth",
  netRevenue: "netRevenue",
  metadata: "metadata",
  type: "type",
  delimiter: "delimiter",
  currency: "currency",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ReportingScalarFieldEnum =
  (typeof ReportingScalarFieldEnum)[keyof typeof ReportingScalarFieldEnum];

export const WorkspaceAccountScalarFieldEnum = {
  id: "id",
  ownerId: "ownerId",
  name: "name",
  legalName: "legalName",
  description: "description",
  logo: "logo",
  metadata: "metadata",
  type: "type",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  startedAt: "startedAt",
  endedAt: "endedAt",
  renewedAt: "renewedAt",
  canceledAt: "canceledAt",
  suspendedAt: "suspendedAt",
  terminatedAt: "terminatedAt",
  agreementSignedAt: "agreementSignedAt",
  agreementExpiresAt: "agreementExpiresAt",
  agreementRenewedAt: "agreementRenewedAt",
} as const;

export type WorkspaceAccountScalarFieldEnum =
  (typeof WorkspaceAccountScalarFieldEnum)[keyof typeof WorkspaceAccountScalarFieldEnum];

export const ReleaseScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ReleaseScalarFieldEnum =
  (typeof ReleaseScalarFieldEnum)[keyof typeof ReleaseScalarFieldEnum];

export const TrackScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type TrackScalarFieldEnum =
  (typeof TrackScalarFieldEnum)[keyof typeof TrackScalarFieldEnum];

export const VideoScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type VideoScalarFieldEnum =
  (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum];

export const RingtoneScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type RingtoneScalarFieldEnum =
  (typeof RingtoneScalarFieldEnum)[keyof typeof RingtoneScalarFieldEnum];

export const ArtistScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ArtistScalarFieldEnum =
  (typeof ArtistScalarFieldEnum)[keyof typeof ArtistScalarFieldEnum];

export const PerformerScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PerformerScalarFieldEnum =
  (typeof PerformerScalarFieldEnum)[keyof typeof PerformerScalarFieldEnum];

export const ProducerAndEngineerScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ProducerAndEngineerScalarFieldEnum =
  (typeof ProducerAndEngineerScalarFieldEnum)[keyof typeof ProducerAndEngineerScalarFieldEnum];

export const ArtistPerformerProducerAndEngineerScalarFieldEnum = {
  id: "id",
  artistId: "artistId",
  performerId: "performerId",
  producerAndEngineerId: "producerAndEngineerId",
  name: "name",
  legalName: "legalName",
  avatar: "avatar",
  metadata: "metadata",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ArtistPerformerProducerAndEngineerScalarFieldEnum =
  (typeof ArtistPerformerProducerAndEngineerScalarFieldEnum)[keyof typeof ArtistPerformerProducerAndEngineerScalarFieldEnum];

export const WriterScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type WriterScalarFieldEnum =
  (typeof WriterScalarFieldEnum)[keyof typeof WriterScalarFieldEnum];

export const PublisherScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PublisherScalarFieldEnum =
  (typeof PublisherScalarFieldEnum)[keyof typeof PublisherScalarFieldEnum];

export const LabelScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type LabelScalarFieldEnum =
  (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum];

export const TransactionScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type TransactionScalarFieldEnum =
  (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum];

export const WithdrawalScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  metadata: "metadata",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type WithdrawalScalarFieldEnum =
  (typeof WithdrawalScalarFieldEnum)[keyof typeof WithdrawalScalarFieldEnum];

export const ReportScalarFieldEnum = {
  id: "id",
  reportingId: "reportingId",
  metadata: "metadata",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ReportScalarFieldEnum =
  (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum];

export const SharedWorkspaceAccountAccessScalarFieldEnum = {
  id: "id",
  workspaceAccountId: "workspaceAccountId",
  userId: "userId",
  assignerId: "assignerId",
  allReleases: "allReleases",
  allTracks: "allTracks",
  allVideos: "allVideos",
  allRingtones: "allRingtones",
  allArtists: "allArtists",
  allPerformers: "allPerformers",
  allProducersAndEngineers: "allProducersAndEngineers",
  allWriters: "allWriters",
  allPublishers: "allPublishers",
  allLabels: "allLabels",
  allTransactions: "allTransactions",
  allWithdraws: "allWithdraws",
  allConsumptions: "allConsumptions",
  allEngagements: "allEngagements",
  allRevenues: "allRevenues",
  allGeos: "allGeos",
  releaseAccessLevel: "releaseAccessLevel",
  trackAccessLevel: "trackAccessLevel",
  videoAccessLevel: "videoAccessLevel",
  ringtoneAccessLevel: "ringtoneAccessLevel",
  artistAccessLevel: "artistAccessLevel",
  performerAccessLevel: "performerAccessLevel",
  producerAndEngineerAccessLevel: "producerAndEngineerAccessLevel",
  writerAccessLevel: "writerAccessLevel",
  publisherAccessLevel: "publisherAccessLevel",
  labelAccessLevel: "labelAccessLevel",
  transactionAccessLevel: "transactionAccessLevel",
  withdrawsAccessLevel: "withdrawsAccessLevel",
  consumptionAccessLevel: "consumptionAccessLevel",
  engagementAccessLevel: "engagementAccessLevel",
  revenueAccessLevel: "revenueAccessLevel",
  geoAccessLevel: "geoAccessLevel",
  metadata: "metadata",
  role: "role",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  expiresAt: "expiresAt",
  suspendedAt: "suspendedAt",
} as const;

export type SharedWorkspaceAccountAccessScalarFieldEnum =
  (typeof SharedWorkspaceAccountAccessScalarFieldEnum)[keyof typeof SharedWorkspaceAccountAccessScalarFieldEnum];

export const RightsManagementScalarFieldEnum = {
  id: "id",
  userId: "userId",
  metadata: "metadata",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type RightsManagementScalarFieldEnum =
  (typeof RightsManagementScalarFieldEnum)[keyof typeof RightsManagementScalarFieldEnum];

export const AuditLogScalarFieldEnum = {
  id: "id",
  userId: "userId",
  entityId: "entityId",
  bySystem: "bySystem",
  description: "description",
  metadata: "metadata",
  action: "action",
  entity: "entity",
  createdAt: "createdAt",
} as const;

export type AuditLogScalarFieldEnum =
  (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

export const SortOrder = {
  asc: "asc",
  desc: "desc",
} as const;

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull,
} as const;

export type NullableJsonNullValueInput =
  (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

export const QueryMode = {
  default: "default",
  insensitive: "insensitive",
} as const;

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull,
} as const;

export type JsonNullValueFilter =
  (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

export const NullsOrder = {
  first: "first",
  last: "last",
} as const;

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

/**
 * Field references
 */

/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "String"
>;

/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "String[]"
>;

/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Json"
>;

/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "QueryMode"
>;

/**
 * Reference to a field of type 'ROLE'
 */
export type EnumROLEFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "ROLE"
>;

/**
 * Reference to a field of type 'ROLE[]'
 */
export type ListEnumROLEFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "ROLE[]"
>;

/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DateTime"
>;

/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DateTime[]"
>;

/**
 * Reference to a field of type 'SESSION_DEVICE_TYPE'
 */
export type EnumSESSION_DEVICE_TYPEFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "SESSION_DEVICE_TYPE">;

/**
 * Reference to a field of type 'SESSION_DEVICE_TYPE[]'
 */
export type ListEnumSESSION_DEVICE_TYPEFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "SESSION_DEVICE_TYPE[]">;

/**
 * Reference to a field of type 'USER_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumUSER_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "USER_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'USER_SYSTEM_ACCESS_LEVEL'
 */
export type EnumUSER_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "USER_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'WORKSPACE_ACCOUNT_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumWORKSPACE_ACCOUNT_SYSTEM_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "WORKSPACE_ACCOUNT_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'WORKSPACE_ACCOUNT_SYSTEM_ACCESS_LEVEL'
 */
export type EnumWORKSPACE_ACCOUNT_SYSTEM_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "WORKSPACE_ACCOUNT_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'REPORTING_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumREPORTING_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REPORTING_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'REPORTING_SYSTEM_ACCESS_LEVEL'
 */
export type EnumREPORTING_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REPORTING_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'RELEASE_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumRELEASE_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RELEASE_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'RELEASE_SYSTEM_ACCESS_LEVEL'
 */
export type EnumRELEASE_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RELEASE_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'TRACK_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumTRACK_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TRACK_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'TRACK_SYSTEM_ACCESS_LEVEL'
 */
export type EnumTRACK_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TRACK_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'VIDEO_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumVIDEO_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "VIDEO_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'VIDEO_SYSTEM_ACCESS_LEVEL'
 */
export type EnumVIDEO_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "VIDEO_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'RINGTONE_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumRINGTONE_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RINGTONE_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'RINGTONE_SYSTEM_ACCESS_LEVEL'
 */
export type EnumRINGTONE_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RINGTONE_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'ARTIST_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumARTIST_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ARTIST_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'ARTIST_SYSTEM_ACCESS_LEVEL'
 */
export type EnumARTIST_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ARTIST_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'PERFORMER_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumPERFORMER_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "PERFORMER_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'PERFORMER_SYSTEM_ACCESS_LEVEL'
 */
export type EnumPERFORMER_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "PERFORMER_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'PRODUCER_AND_ENGINEER_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumPRODUCER_AND_ENGINEER_SYSTEM_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<
  $PrismaModel,
  "PRODUCER_AND_ENGINEER_SYSTEM_ACCESS_LEVEL[]"
>;

/**
 * Reference to a field of type 'PRODUCER_AND_ENGINEER_SYSTEM_ACCESS_LEVEL'
 */
export type EnumPRODUCER_AND_ENGINEER_SYSTEM_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<
  $PrismaModel,
  "PRODUCER_AND_ENGINEER_SYSTEM_ACCESS_LEVEL"
>;

/**
 * Reference to a field of type 'WRITER_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumWRITER_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WRITER_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'WRITER_SYSTEM_ACCESS_LEVEL'
 */
export type EnumWRITER_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WRITER_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'PUBLISHER_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumPUBLISHER_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "PUBLISHER_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'PUBLISHER_SYSTEM_ACCESS_LEVEL'
 */
export type EnumPUBLISHER_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "PUBLISHER_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'LABEL_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumLABEL_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "LABEL_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'LABEL_SYSTEM_ACCESS_LEVEL'
 */
export type EnumLABEL_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "LABEL_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'TRANSACTION_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumTRANSACTION_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TRANSACTION_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'TRANSACTION_SYSTEM_ACCESS_LEVEL'
 */
export type EnumTRANSACTION_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TRANSACTION_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'WITHDRAW_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumWITHDRAW_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WITHDRAW_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'WITHDRAW_SYSTEM_ACCESS_LEVEL'
 */
export type EnumWITHDRAW_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WITHDRAW_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'CONSUMPTION_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumCONSUMPTION_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "CONSUMPTION_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'CONSUMPTION_SYSTEM_ACCESS_LEVEL'
 */
export type EnumCONSUMPTION_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "CONSUMPTION_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'ENGAGEMENT_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumENGAGEMENT_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ENGAGEMENT_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'ENGAGEMENT_SYSTEM_ACCESS_LEVEL'
 */
export type EnumENGAGEMENT_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ENGAGEMENT_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'REVENUE_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumREVENUE_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REVENUE_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'REVENUE_SYSTEM_ACCESS_LEVEL'
 */
export type EnumREVENUE_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REVENUE_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'GEO_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumGEO_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "GEO_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'GEO_SYSTEM_ACCESS_LEVEL'
 */
export type EnumGEO_SYSTEM_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "GEO_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'RIGHTS_MANAGEMENT_SYSTEM_ACCESS_LEVEL[]'
 */
export type ListEnumRIGHTS_MANAGEMENT_SYSTEM_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "RIGHTS_MANAGEMENT_SYSTEM_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'RIGHTS_MANAGEMENT_SYSTEM_ACCESS_LEVEL'
 */
export type EnumRIGHTS_MANAGEMENT_SYSTEM_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "RIGHTS_MANAGEMENT_SYSTEM_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Float"
>;

/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Float[]"
>;

/**
 * Reference to a field of type 'REPORTING_TYPE'
 */
export type EnumREPORTING_TYPEFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "REPORTING_TYPE"
>;

/**
 * Reference to a field of type 'REPORTING_TYPE[]'
 */
export type ListEnumREPORTING_TYPEFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REPORTING_TYPE[]">;

/**
 * Reference to a field of type 'REPORTING_DELIMITER'
 */
export type EnumREPORTING_DELIMITERFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REPORTING_DELIMITER">;

/**
 * Reference to a field of type 'REPORTING_DELIMITER[]'
 */
export type ListEnumREPORTING_DELIMITERFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REPORTING_DELIMITER[]">;

/**
 * Reference to a field of type 'REPORTING_CURRENCY'
 */
export type EnumREPORTING_CURRENCYFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REPORTING_CURRENCY">;

/**
 * Reference to a field of type 'REPORTING_CURRENCY[]'
 */
export type ListEnumREPORTING_CURRENCYFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REPORTING_CURRENCY[]">;

/**
 * Reference to a field of type 'WORKSPACE_ACCOUNT_TYPE'
 */
export type EnumWORKSPACE_ACCOUNT_TYPEFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WORKSPACE_ACCOUNT_TYPE">;

/**
 * Reference to a field of type 'WORKSPACE_ACCOUNT_TYPE[]'
 */
export type ListEnumWORKSPACE_ACCOUNT_TYPEFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WORKSPACE_ACCOUNT_TYPE[]">;

/**
 * Reference to a field of type 'RELEASE_STATUS'
 */
export type EnumRELEASE_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "RELEASE_STATUS"
>;

/**
 * Reference to a field of type 'RELEASE_STATUS[]'
 */
export type ListEnumRELEASE_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RELEASE_STATUS[]">;

/**
 * Reference to a field of type 'VIDEO_STATUS'
 */
export type EnumVIDEO_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "VIDEO_STATUS"
>;

/**
 * Reference to a field of type 'VIDEO_STATUS[]'
 */
export type ListEnumVIDEO_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "VIDEO_STATUS[]"
>;

/**
 * Reference to a field of type 'RINGTONE_STATUS'
 */
export type EnumRINGTONE_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "RINGTONE_STATUS"
>;

/**
 * Reference to a field of type 'RINGTONE_STATUS[]'
 */
export type ListEnumRINGTONE_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RINGTONE_STATUS[]">;

/**
 * Reference to a field of type 'ARTIST_STATUS'
 */
export type EnumARTIST_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "ARTIST_STATUS"
>;

/**
 * Reference to a field of type 'ARTIST_STATUS[]'
 */
export type ListEnumARTIST_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ARTIST_STATUS[]">;

/**
 * Reference to a field of type 'PUBLISHER_STATUS'
 */
export type EnumPUBLISHER_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "PUBLISHER_STATUS"
>;

/**
 * Reference to a field of type 'PUBLISHER_STATUS[]'
 */
export type ListEnumPUBLISHER_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "PUBLISHER_STATUS[]">;

/**
 * Reference to a field of type 'LABEL_STATUS'
 */
export type EnumLABEL_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "LABEL_STATUS"
>;

/**
 * Reference to a field of type 'LABEL_STATUS[]'
 */
export type ListEnumLABEL_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "LABEL_STATUS[]"
>;

/**
 * Reference to a field of type 'TRANSACTION_STATUS'
 */
export type EnumTRANSACTION_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TRANSACTION_STATUS">;

/**
 * Reference to a field of type 'TRANSACTION_STATUS[]'
 */
export type ListEnumTRANSACTION_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TRANSACTION_STATUS[]">;

/**
 * Reference to a field of type 'WITHDRAWAL_STATUS'
 */
export type EnumWITHDRAWAL_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WITHDRAWAL_STATUS">;

/**
 * Reference to a field of type 'WITHDRAWAL_STATUS[]'
 */
export type ListEnumWITHDRAWAL_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WITHDRAWAL_STATUS[]">;

/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Boolean"
>;

/**
 * Reference to a field of type 'RELEASE_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumRELEASE_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RELEASE_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'RELEASE_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumRELEASE_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RELEASE_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'TRACK_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumTRACK_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TRACK_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'TRACK_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumTRACK_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TRACK_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'VIDEO_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumVIDEO_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "VIDEO_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'VIDEO_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumVIDEO_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "VIDEO_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'RINGTONE_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumRINGTONE_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RINGTONE_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'RINGTONE_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumRINGTONE_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RINGTONE_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'ARTIST_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumARTIST_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ARTIST_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'ARTIST_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumARTIST_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ARTIST_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'PERFORMER_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumPERFORMER_WORKSPACE_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "PERFORMER_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'PERFORMER_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumPERFORMER_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "PERFORMER_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'PRODUCER_AND_ENGINEER_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumPRODUCER_AND_ENGINEER_WORKSPACE_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<
  $PrismaModel,
  "PRODUCER_AND_ENGINEER_WORKSPACE_ACCESS_LEVEL[]"
>;

/**
 * Reference to a field of type 'PRODUCER_AND_ENGINEER_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumPRODUCER_AND_ENGINEER_WORKSPACE_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<
  $PrismaModel,
  "PRODUCER_AND_ENGINEER_WORKSPACE_ACCESS_LEVEL"
>;

/**
 * Reference to a field of type 'WRITER_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumWRITER_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WRITER_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'WRITER_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumWRITER_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WRITER_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'PUBLISHER_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumPUBLISHER_WORKSPACE_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "PUBLISHER_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'PUBLISHER_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumPUBLISHER_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "PUBLISHER_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'LABEL_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumLABEL_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "LABEL_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'LABEL_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumLABEL_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "LABEL_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'TRANSACTION_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumTRANSACTION_WORKSPACE_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "TRANSACTION_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'TRANSACTION_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumTRANSACTION_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TRANSACTION_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'WITHDRAWS_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumWITHDRAWS_WORKSPACE_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "WITHDRAWS_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'WITHDRAWS_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumWITHDRAWS_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WITHDRAWS_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'CONSUMPTION_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumCONSUMPTION_WORKSPACE_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "CONSUMPTION_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'CONSUMPTION_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumCONSUMPTION_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "CONSUMPTION_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'ENGAGEMENT_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumENGAGEMENT_WORKSPACE_ACCESS_LEVELFieldRefInput<
  $PrismaModel,
> = FieldRefInputType<$PrismaModel, "ENGAGEMENT_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'ENGAGEMENT_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumENGAGEMENT_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ENGAGEMENT_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'REVENUE_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumREVENUE_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REVENUE_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'REVENUE_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumREVENUE_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "REVENUE_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'GEO_WORKSPACE_ACCESS_LEVEL[]'
 */
export type ListEnumGEO_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "GEO_WORKSPACE_ACCESS_LEVEL[]">;

/**
 * Reference to a field of type 'GEO_WORKSPACE_ACCESS_LEVEL'
 */
export type EnumGEO_WORKSPACE_ACCESS_LEVELFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "GEO_WORKSPACE_ACCESS_LEVEL">;

/**
 * Reference to a field of type 'WORKSPACE_ACCOUNT_ACCESS_ROLE'
 */
export type EnumWORKSPACE_ACCOUNT_ACCESS_ROLEFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WORKSPACE_ACCOUNT_ACCESS_ROLE">;

/**
 * Reference to a field of type 'WORKSPACE_ACCOUNT_ACCESS_ROLE[]'
 */
export type ListEnumWORKSPACE_ACCOUNT_ACCESS_ROLEFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "WORKSPACE_ACCOUNT_ACCESS_ROLE[]">;

/**
 * Reference to a field of type 'RIGHTS_MANAGEMENT_STATUS'
 */
export type EnumRIGHTS_MANAGEMENT_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RIGHTS_MANAGEMENT_STATUS">;

/**
 * Reference to a field of type 'RIGHTS_MANAGEMENT_STATUS[]'
 */
export type ListEnumRIGHTS_MANAGEMENT_STATUSFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RIGHTS_MANAGEMENT_STATUS[]">;

/**
 * Reference to a field of type 'AUDIT_LOG_ACTION'
 */
export type EnumAUDIT_LOG_ACTIONFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "AUDIT_LOG_ACTION"
>;

/**
 * Reference to a field of type 'AUDIT_LOG_ACTION[]'
 */
export type ListEnumAUDIT_LOG_ACTIONFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "AUDIT_LOG_ACTION[]">;

/**
 * Reference to a field of type 'AUDIT_LOG_ENTITY'
 */
export type EnumAUDIT_LOG_ENTITYFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "AUDIT_LOG_ENTITY"
>;

/**
 * Reference to a field of type 'AUDIT_LOG_ENTITY[]'
 */
export type ListEnumAUDIT_LOG_ENTITYFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "AUDIT_LOG_ENTITY[]">;

/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Int"
>;

/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Int[]"
>;

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number;
};

export const defineExtension = runtime.Extensions
  .defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<
  "define",
  TypeMapCb,
  runtime.Types.Extensions.DefaultArgs
>;
export type DefaultPrismaClient = PrismaClient;
export type ErrorFormat = "pretty" | "colorless" | "minimal";
export type PrismaClientOptions = (
  | {
      /**
       * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
       */
      adapter: runtime.SqlDriverAdapterFactory;
      accelerateUrl?: never;
    }
  | {
      /**
       * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
       */
      accelerateUrl: string;
      adapter?: never;
    }
) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat;
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   *
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   *
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   *
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[];
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number;
    timeout?: number;
    isolationLevel?: TransactionIsolationLevel;
  };
  /**
   * Global configuration for omitting model fields by default.
   *
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig;
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   *
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[];
};
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit;
  session?: Prisma.SessionOmit;
  systemAccess?: Prisma.SystemAccessOmit;
  reporting?: Prisma.ReportingOmit;
  workspaceAccount?: Prisma.WorkspaceAccountOmit;
  release?: Prisma.ReleaseOmit;
  track?: Prisma.TrackOmit;
  video?: Prisma.VideoOmit;
  ringtone?: Prisma.RingtoneOmit;
  artist?: Prisma.ArtistOmit;
  performer?: Prisma.PerformerOmit;
  producerAndEngineer?: Prisma.ProducerAndEngineerOmit;
  artistPerformerProducerAndEngineer?: Prisma.ArtistPerformerProducerAndEngineerOmit;
  writer?: Prisma.WriterOmit;
  publisher?: Prisma.PublisherOmit;
  label?: Prisma.LabelOmit;
  transaction?: Prisma.TransactionOmit;
  withdrawal?: Prisma.WithdrawalOmit;
  report?: Prisma.ReportOmit;
  sharedWorkspaceAccountAccess?: Prisma.SharedWorkspaceAccountAccessOmit;
  rightsManagement?: Prisma.RightsManagementOmit;
  auditLog?: Prisma.AuditLogOmit;
};

/* Types for Logging */
export type LogLevel = "info" | "query" | "warn" | "error";
export type LogDefinition = {
  level: LogLevel;
  emit: "stdout" | "event";
};

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T["level"] : T
>;

export type GetEvents<T extends any[]> =
  T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

export type QueryEvent = {
  timestamp: Date;
  query: string;
  params: string;
  duration: number;
  target: string;
};

export type LogEvent = {
  timestamp: Date;
  message: string;
  target: string;
};
/* End Types for Logging */

export type PrismaAction =
  | "findUnique"
  | "findUniqueOrThrow"
  | "findMany"
  | "findFirst"
  | "findFirstOrThrow"
  | "create"
  | "createMany"
  | "createManyAndReturn"
  | "update"
  | "updateMany"
  | "updateManyAndReturn"
  | "upsert"
  | "delete"
  | "deleteMany"
  | "executeRaw"
  | "queryRaw"
  | "aggregate"
  | "count"
  | "runCommandRaw"
  | "findRaw"
  | "groupBy";

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<
  DefaultPrismaClient,
  runtime.ITXClientDenyList
>;
